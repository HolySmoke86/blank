#ifndef BLANK_WORLD_WORLD_HPP_
#define BLANK_WORLD_WORLD_HPP_

#include "ChunkStore.hpp"
#include "Entity.hpp"
#include "Generator.hpp"
#include "Player.hpp"

#include <cstdint>
#include <list>
#include <string>
#include <vector>
#include <glm/glm.hpp>


namespace blank {

class BlockTypeRegistry;
class EntityCollision;
class Viewport;
class WorldCollision;

class World {

public:
	struct Config {
		std::string name = "default";
		// initial player position
		glm::vec3 spawn = { 0.0f, 0.0f, 0.0f };
		// direction facing towards(!) the light
		glm::vec3 light_direction = { -1.0f, -3.0f, -2.0f };
		// fade out reaches 1/e (0.3679) at 1/fog_density,
		// gets less than 0.01 at e/(2 * fog_density)
		// I chose 0.011 because it yields 91 and 124 for those, so
		// slightly less than 6 and 8 chunks
		float fog_density = 0.011f;
	};

	World(const BlockTypeRegistry &, const Config &);
	~World();

	const std::string &Name() const noexcept { return config.name; }

	/// check if this ray hits a block
	/// depth in the collision is the distance between the ray's
	/// origin and the intersection point
	/// M is the global transform for given reference chunk
	bool Intersection(
		const Ray &,
		const glm::mat4 &M,
		const Chunk::Pos &reference,
		WorldCollision &);

	/// check if this ray hits an entity
	/// intersections with the reference are not tested
	/// M is the global transform for the chunk of given reference entity
	bool Intersection(
		const Ray &,
		const glm::mat4 &M,
		const Entity &reference,
		EntityCollision &);

	/// check if given entity intersects with the world
	bool Intersection(const Entity &e, std::vector<WorldCollision> &);
	void Resolve(Entity &e, std::vector<WorldCollision> &);

	const BlockTypeRegistry &BlockTypes() noexcept { return block_type; }
	ChunkStore &Chunks() noexcept { return chunks; }

	/// add player with given name
	/// returns nullptr in entity if the name is already taken
	Player AddPlayer(const std::string &name);
	/// add player with given name and ID
	/// returns nullptr in entity if the name or ID is already taken
	Player AddPlayer(const std::string &name, std::uint32_t id);
	/// add an entity with an autogenerated ID
	Entity &AddEntity();
	/// add entity with given ID
	/// returns nullptr if the ID is already taken
	Entity *AddEntity(std::uint32_t id);

	const std::vector<Player> &Players() const noexcept { return players; }
	std::list<Entity> &Entities() noexcept { return entities; }
	const std::list<Entity> &Entities() const noexcept { return entities; }

	void Update(int dt);

	void Render(Viewport &);

private:
	using EntityHandle = std::list<Entity>::iterator;
	EntityHandle RemoveEntity(EntityHandle &);

private:
	Config config;

	const BlockTypeRegistry &block_type;

	ChunkStore chunks;
	ChunkIndex &spawn_index;

	std::vector<Player> players;
	std::list<Entity> entities;

	glm::vec3 light_direction;
	float fog_density;

};

}

#endif
